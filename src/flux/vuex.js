import * as fluxModules from './module'
import Vuex from 'vuex' // vuex2
import { genFluxModules } from './utils/generate'

export const registerVuexModules = (entry, options = {}) => {
  let { store, ...rest } = options || {}

  if (store) {
    rest.onNewAction = exposeModuleUtils.callbackNewActionForExpose
    rest.onNewGetter = exposeModuleUtils.callbackNewGetterForExpose
    rest.onModuleGenerate = (payload) => {
      let { rawModule } = payload
      rawModule.$expose = {}
      rawModule.M.vuex = Vuex
      rawModule.M.vuexNormalizeMap = {getters: {}, actions: {}}
    }
    rest.onModuleGenerated = (module, payload) => {
      store.registerModule(module.M + '', module)
      exposeModuleUtils(module, {$store: store})

      delete module.M.vuexNormalizeMap
    }
  }

  return genFluxModules(entry, rest)
}

/**
 * another callee for enhanceVuexModules
 *
 * enhance the capability of one vuex2-style module,
 * make it has capability to call it's own actions and getters(getter function recommended)
 * in **raw environment**, so the vm object with one '$store' field is required.
 *
 * @param  {Object} module         [vuex2 style module]
 * @param  {Object} options.$store [$store generated by new Vuex.Store()]
 * @param  {Object} options.vm     [description]
 * @return {Object}                [the module self]
 */
export function exposeModuleUtils (module, {$store, vm = {$store}}) {
  if (typeof module !== 'object') {
    console.warn(`invalid vuex2-style module supplied, it should be one object with fields 'actions' and 'getters'`)
    return
  }

  if (!vm || !(vm.$store instanceof Vuex.Store)) {
    console.warn(`invalid vm supplied, it should be one object with field '$store', and vm.$store must be the instance of Vuex.Store constructor.`)
    return
  }

  let { M = {} } = module,
      {
        exposeAction = true,
        exposeGetter = true,
        exposeMutation = true
      } = M

  if (exposeAction) {
    let actions = module.actions
    let exposeActionMap = M.vuexNormalizeMap.actions
    for (let origKey in exposeActionMap) {
      let realKey = exposeActionMap[origKey]
      module.$expose[origKey] = (...args) => $store.dispatch(realKey, ...args)
    }
  }

  if (exposeGetter) {
    let exposeGetterMap = M.vuexNormalizeMap.getters
    for (let origKey in exposeGetterMap) {
      let realKey = exposeGetterMap[origKey]
      Object.defineProperty(module.$expose, origKey, {
        get () {
          return $store.getters[realKey]
        }
      })
    }
  }

  return module
}

exposeModuleUtils.allFlag = ['all', 'true']

exposeModuleUtils.callbackNewGetterForExpose = (payload) => {
  let { rawModule } = payload || {},
      { M } = rawModule || {},
      {
        exposeGetter = true
      } = M

  let all = exposeGetter && exposeModuleUtils.allFlag.indexOf(exposeGetter.toString()) > -1
  if (all || typeof exposeGetter === 'object') {
    let { getter, origKey, newKey } = payload || {}
    getter.origKey = origKey
    getter.newKey = newKey
    if (all || exposeGetter && exposeGetter.hasOwnProperty(origKey)) {
      M.vuexNormalizeMap.getters[origKey] = newKey
    }
  }
}

exposeModuleUtils.callbackNewActionForExpose = (payload) => {
  let { rawModule } = payload || {},
      { M } = rawModule || {},
      {
        exposeAction = true
      } = M

  let all = exposeAction && exposeModuleUtils.allFlag.indexOf(exposeAction.toString()) > -1
  if (all || typeof exposeAction === 'object') {
    let { action, origKey, newKey } = payload || {}
    action.origKey = origKey
    action.newKey = newKey
    if (all || exposeAction && exposeAction.hasOwnProperty(origKey)) {
      M.vuexNormalizeMap.actions[origKey] = newKey
    }
  }
}

/**
 * Bind the vm with `$store` for the getters genareted by `Vuex.mapGetters` in raw environment
 *
 * @return {[type]} [description]
 */
export function bindVmToGetterHash (getterHash, vm, options) {
  let { exposeGetterMap = {} } = options || {}
  for (let key in getterHash) {
    let _type = typeof getterHash[key]
    switch (_type) {
      case 'function':
        let rawFn = getterHash[key]
        // provide args when `getter` is one `function to being called` rather than just `property getter function`
        if (typeof rawFn === 'function' && (rawFn.__expose__ || exposeGetterMap[key])) {
          getterHash[key] = (...args) => rawFn.call(vm)(...args)
        } else {
          getterHash[key] = rawFn.call(vm)
        }
        break
      default:
        break
    }
  }
  return getterHash
}

/**
 * depreacted, never use.
 *
 * Bind the vm with `$store` for the getters genareted by `Vuex.mapActions` in raw environment
 *
 * @return {[type]} [description]
 */
export function bindVmToGetter (getterFn, vm) {
  if ('$store' in vm && typeof vm.$store === 'object') {
    let _type = typeof getterFn
    switch (_type) {
      case 'function':
        let rawFn = getterFn
        return (...args) => rawFn.call(vm)(...args)
      default:
        console.warn(`invalid getter for vuex module supplied, it must has one function.`)
        break
    }
  } else {
    console.warn(`invalid vm supplied, it must has one field named '$store' and with 'object(Vuex.Store)' type.`)
  }
}

/**
 *
 * Bind the vm with `$store` for the actions genareted by `Vuex.mapActions` in raw environment
 *
 * @return {[type]} [description]
 */
export function bindVmToActionHash (actionHash, vm) {
  for (let key in actionHash) {
    let rawFn = actionHash[key]
    actionHash[key] = rawFn.bind(vm)
  }
  return actionHash
}

/**
 * depreacted, never use.
 *
 * Bind the vm with `$store` for the actions genareted by `Vuex.mapActions` in raw environment
 *
 * @return {[type]} [description]
 */
export function bindVmToAction (action, vm) {
  if ('$store' in vm && typeof vm.$store === 'object') {
    return action.bind(vm)
  } else {
    console.warn(`invalid vm supplied, it must has one field named '$store' and with 'object(Vuex.Store)' type.`)
  }
}

// ====================================== old utils =================================== //

export const genVuexModules = genFluxModules

/**
 * enhance the capability of one vuex2-style module,
 * make it has capability to call it's own actions and getters(getter function recommended)
 * in **raw environment**, so the vm object with one '$store' field is required.
 *
 * @param  {Object} module         [vuex2 style module]
 * @param  {Object} options.$store [$store generated by new Vuex.Store()]
 * @param  {Object} options.vm     [description]
 * @return {Object}                [the module self]
 */
export function enhanceVuexModules (module, {$store, vm = {$store}}) {
  if (typeof module !== 'object') {
    console.warn(`invalid vuex2-style module supplied, it should be one object with fields 'actions' and 'getters'`)
    return
  }

  if (!vm || !(vm.$store instanceof Vuex.Store)) {
    console.warn(`invalid vm supplied, it should be one object with field '$store', and vm.$store must be the instance of Vuex.Store constructor.`)
    return
  }

  let { M = {} } = module,
      {
        enhanceModuleAction = true,
        enhanceModuleGetter = true,
        enhanceModuleMutation = true
      } = M

  if (enhanceModuleAction) {
    let actions = module.actions

    if (typeof M.vactions$ !== 'object') M.vactions$ = {}

    for (let aKey in actions) {
      let { noHash } = actions[aKey] || {}
      if (!noHash || !noHash.origKey || !noHash.newKey) {
        continue // ignore the module's action without the 'noHash' descriptor
      }
      M.vactions$[noHash.origKey] = `${noHash.newKey}`
    }
    M.vactions$ = bindVmToActionHash(Vuex.mapActions(M.vactions$), vm)
  }

  if (enhanceModuleGetter) {
    let getters = module.getters
    if (typeof M.vgetters$ !== 'object') M.vgetters$ = {}
    for (let gKey in getters) {
      let { noHash } = getters[gKey] || {}
      if (!noHash || !noHash.origKey || !noHash.newKey) {
        continue // ignore the module's getter without the 'noHash' descriptor
      }
      M.vgetters$[noHash.origKey] = `${noHash.newKey}`
    }

    M.vgetters$ = bindVmToGetterHash(Vuex.mapGetters(M.vgetters$), vm)
  }

  return module
}

/**
 * depreacted, never use.
 *
 * never change module in this definition.
 *
 * @param  {Object} options.module [description]
 * @param  {Object} runtimeStore   [description]
 * @return {[type]}                [description]
 */
export function getModuleStateFromStore ({module = {}, runtimeStore = {}}) {
  if (!module.hasOwnProperty('M')) {
    console.warn(`no 'M' in module`)
    return
  }

  let { M = {} } = module || {}
  return runtimeStore.state[M.GETTER_KEY]
}
